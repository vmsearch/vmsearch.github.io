<!DOCTYPE html>
<html lang="zh_cn">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="duma" />

        <meta name="description" content="产生背景 作为协议主要发起方，intel在2019年首次提出了cxl协议并联合国内外一众芯片和硬件公司组成了cxl联盟。在cxl协议之前，pcie作为节点设备之间常用的连接协议。cxl的提出主要是希望填补一下pcie在异构计算和分离式数据中心方面的不足。cxl的优势可以总结如下： 提供高效的share mem pool的访问机制 cpu和第三方accelerators之间数据交互更加高效 cxl协议的低时延特性(ns级)让内存拉远成为可能。 与cxl对等的还有ccix和nvlink这两种高效互连协议，这里需要专门说一下 …
" />
        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="cxl, cxl device, articles, " />
        <title>初识cxl协议&amp;cxl device  · KernelNote - AI基础设施技术博客
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="./theme/css/elegant.prod.css" media="screen">
        <link rel="stylesheet" type="text/css" href="./theme/css/custom.css" media="screen">

        <link href="https://kernelnote.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="KernelNote - AI基础设施技术博客 - Full Atom Feed" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LRRMJ08SPD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LRRMJ08SPD');
</script>



    </head>
    <body>
        <div id="content">
            <div class="navbar navbar-static-top">
                <div class="navbar-inner">
                    <div class="container-fluid">
                        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </a>
                        <a class="brand" href="./"><span class=site-name>KernelNote - AI基础设施技术博客</span></a>
                        <div class="nav-collapse collapse">
                            <ul class="nav pull-right top-menu">
                                <li >
                                    <a href=
                                       .
                                    >Home</a>
                                </li>
                                <li ><a href="./pages/about.html">about</a></li>
                                <li ><a href="./categories.html">Categories</a></li>
                                <li ><a href="./tags.html">Tags</a></li>
                                <li ><a href="./archives.html">Archives</a></li>
                                <li><form class="navbar-search" action="./search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container-fluid">
                <div class="row-fluid">
                    <div class="span1"></div>
                    <div class="span10">
<!-- 文章头部区域 -->
<header class="article-header">
    <div class="article-header-container">
        <!-- 作者信息区域 -->
        <div class="article-author-section">
            <img src="./images/wechat.jpeg" alt="周毅博" class="author-avatar">
            <div class="author-info">
                <h3 class="author-name">周宜波</h3>
                <p class="author-title">AI基础设施架构师 | AI Agent专家</p>
            </div>
        </div>

        <!-- 文章标题和元信息 -->
        <div class="article-meta-section">
            <h1 class="article-title">
                初识cxl协议&cxl device
            </h1>

            <div class="article-meta-info">
                <div class="meta-item">
                    <span class="meta-icon">📅</span>
                    <time datetime="2022-07-16T00:00:00+08:00">六 16 七月 2022</time>
                </div>
                <div class="meta-item">
                    <span class="meta-icon">📁</span>
                    <span class="category-tag">articles</span>
                </div>
                <div class="meta-item">
                    <span class="meta-icon">🏷️</span>
                    <span class="article-tag">cxl</span>
                    <span class="article-tag">cxl device</span>
                </div>
            </div>

            <!-- 多媒体链接区域 -->
        </div>
    </div>
</header>

<!-- 文章主体内容 -->
<div class="article-container">
    <div class="article-main">
        <!-- 文章内容 -->
            <main class="article-content article-content-no-toc">
                
                <h4>产生背景</h4>
<p>作为协议主要发起方，intel在2019年首次提出了cxl协议并联合国内外一众芯片和硬件公司组成了cxl联盟。在cxl协议之前，pcie作为节点设备之间常用的连接协议。cxl的提出主要是希望填补一下pcie在异构计算和分离式数据中心方面的不足。cxl的优势可以总结如下：</p>
<ul>
<li>
<p>提供高效的share mem pool的访问机制</p>
</li>
<li>
<p>cpu和第三方accelerators之间数据交互更加高效</p>
</li>
<li>
<p>cxl协议的低时延特性(ns级)让内存拉远成为可能。</p>
</li>
</ul>
<p>与cxl对等的还有ccix和nvlink这两种高效互连协议，这里需要专门说一下nvlink。搞gpu的同学应该对它都不陌生，从时间点上来看nvlink在2016年就开始在nv的相关产当中开始使用了，今年nv又把它用在自家的arm cpu跟gpu之间的互连上。intel之所以提出自己的cxl协议，也主要是为了避免nv进一步蚕食自己的数据中心市场，要知道老黄野心远远不止gpu。不过intel在效率上也确实不如nv，否则也不至于到了SPR这一代才开始支持CXL。下面我们就来探索一下cxl协议和base在这些协议上的设备。</p>
<h4>cxl 三种协议</h4>
<p>cxl 协议base在pcie 5.0之上，其提出了三种协议分别如下：</p>
<ul>
<li>
<p>cxl.io
其主要负责cxl设备的发现，设备初始化，bar和配置空间访问，中断以及dma、ATS。</p>
</li>
<li>
<p>cxl.cache
 其重新定义了设备与host主存之间的交互方式。之所以说是重新定义，我们先来看一下在common pcie的场景下设备是如何跟host主存之间进行交互的，大体可以分为下面三个步骤：</p>
<ul>
<li>设备驱动通过dma map相关的api 将host主存映射到设备能访问的io空间。</li>
<li>host 通过写mmio告诉设备该段地址range和大小</li>
<li>设备触发dma操作将数据搬运到设备private mem(如网卡的SRAM)里面。
而在cxl cache 协议模式下，设备是可以cache host的主存的，这种访问方式的时延更加低。如何理解这个cache host主存呢？cxl cache 主要是基于MESI(Modified, Exclusive, Shared, Invalid) cache一致性协议，然后通过request and respose这种工作模型来实现设备跟host之间的数据交互。具体来说，cxl cache硬件分别在每个方向上(host2device and device2host)定义三个channel：request，response，data。具体如下</li>
</ul>
</li>
</ul>
<p><img alt="cxl_cache_channel" src="images/cxl_cache_channel.png">
<center> 图1 cxl.cache channels </center>
如上图所示，channel之间是相互独立的从而保证了数据高性能传输。另外，cxl cache在每个方向上还定义了相关操作的Opcode，大家如果感兴趣可以去看一下相关的spec。这里以device访问host memory为例展示一下相关的流程：</p>
<p><img alt="cxl_d2h" src="images/cxl_d2h.png">
<center> 图2 cxl cache device access host memory</center></p>
<ul>
<li>
<p>cxl.mem
该协议实现了host memory和device memory的统一编址，host cpu能够通过load and store指令直接访问device memory也称之为host managed device memory。hdm底层的存储介质可以是dram也可以pmem。在cxl mem协议之下， cpu 侧的coherency engine作为Master，然后device attached memory作为Subordinate(下属)。Master作为请求的发出方如数据read，write等；而Subordinate作为请求的响应方。由master 发往 subordinate的交互简称为M2S，相反方向称之为S2M。每种交互都有两种不同的消息类型，先来看一下M2S</p>
<ul>
<li>
<p>request without data(Req)</p>
</li>
<li>
<p>request with data(RwD)</p>
</li>
</ul>
</li>
</ul>
<p>接着看一下S2M的两类消息
    - Reponse without data(NDR)</p>
<div class="highlight"><pre><span></span><code>- Repose with Data(RwD)
</code></pre></div>

<p>交互定义的不同Opcodes，具体如下图所示：</p>
<p><img alt="cxl_mem_opcode" src="images/cxl_mem_opcode.png">
<center>图3 M2S request memory Opcodes</center></p>
<h4>cxl三种设备类型</h4>
<p>讲完cxl三种协议实现，我们再来看一下cxl支持的三种不同类型设备。为了让大家有一个整体的认知，我们先上一张整体的架构图</p>
<p><img alt="cxl_device" src="images/cxl_device.png">
<center> 图4 cxl device</center></p>
<p>结合着上面的图我们来来看一下这三种类型设备的异同点：</p>
<ul>
<li>type 1 device</li>
</ul>
<p>从上图可以看到type 1 device 只支持cxl.io和cxl.cache这两种协议，通常用于需要经常访问host主存的一些设备比如网卡和硬件加速器等。</p>
<ul>
<li>type 2 device</li>
</ul>
<p>type 2 device 支持 cxl.cache和cxl.mem，一般都会带有 device attached memory如HBM 或者DDR。这类设备使用的场景是host和device之间需要大量的进行内存访问和数据交互比如gpu等。跟传统pcie设备的device attached memory 区别在于，cxl.mem协议下的 device attached memory跟host 主存是统一编址的，host cpu 访问 type 2 device  attached memory跟访问host 主存没有区别。</p>
<p><img alt="cxl_type2_device" src="images/cxl_type2_device.png">
<center> 图5 type 2 device with attached memory</center></p>
<p>结合上图的这张图我们来聊一下type 2 当中引入的Bias Based  coherency model，在这种model下。HDM可以有两种状态，分别是 Host Bias和Device Bias。当hdm设置为 Host Bias state时，如果设备要访问 HDM则需要先把request发到Host，再由Host完成相关的操作；当hdm 设置为 device Bias state时设备访问HDM时不需要往host发相关的request，前提是需要device保证host侧没有cache的旧数据。需要注意的是，不管是哪种Bias state对host侧来说这些hdm跟host attached memory 都是统一地址的。为了实现Bias model，需要type 2 device实现以下能力</p>
<div class="highlight"><pre><span></span><code><span class="o">-</span><span class="w"> </span><span class="err">实现</span><span class="n">Bias</span><span class="w"> </span><span class="n">table来追踪Bias</span><span class="p">(</span><span class="err">中文可以译为偏差</span><span class="p">)</span><span class="err">，粒度需要细化到</span><span class="n">page</span><span class="err">。</span>

<span class="o">-</span><span class="w"> </span><span class="err">支持使用</span><span class="n">TA</span><span class="p">(</span><span class="n">translation</span><span class="w"> </span><span class="n">agent</span><span class="p">)</span><span class="err">来进行</span><span class="n">Bias</span><span class="w"> </span><span class="n">translation</span><span class="err">，从而能够比较方便的</span><span class="n">flush</span><span class="w"> </span><span class="n">host侧的cache</span><span class="err">。</span>

<span class="o">-</span><span class="w"> </span><span class="err">支持通过</span><span class="nb">load</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">store指令去访问local的memory</span><span class="err">。</span>
</code></pre></div>

<ul>
<li>type 3 device</li>
</ul>
<p>该类型的设备只支持cxl.io 和cxl.mem，这种类型的设备一般作为host memory的扩展来使用，因此cache一致性主要是由cpu侧来保障。至于type 3设备跟host cpu进行交互相关机制会在后续的系列当中进行详细说明。另外，type3设备还支持Multi Logical Device(个人理解跟 pcie sriov 比较类似)，每个MLD可以再细出为16个独立的LD(logical device)，LD与LD之间通过LD-ID一个16bit的identifier来区分。</p>
<h4>总结</h4>
<p>上面介绍了cxl的协议和设备，cxl给后续的设备与host之间的低时延交互以及内存池化都带来了比较多的想象力。后续的文章，将会给大家讲一下cxl设备的发现和枚举流程。</p>

                <!-- 图片画廊 -->
            </main>

        <!-- 文章底部区域 -->
        <footer class="article-footer">
            <!-- 标签区域 -->
            <div class="article-tags-section">
                <h4>🏷️ 相关标签</h4>
                <div class="tags-cloud">
                    <span class="tag-cloud-item">cxl</span>
                    <span class="tag-cloud-item">cxl device</span>
                </div>
            </div>

            <!-- 分享和互动 -->
            <div class="article-interaction">
                <div class="social-share">
                    <h4>🔗 分享这篇文章</h4>
                    <div class="share-buttons">
                        <a href="#" class="share-btn twitter" target="_blank">𝕏 Twitter</a>
                        <a href="#" class="share-btn weibo" target="_blank">📝 微博</a>
                        <a href="#" class="share-btn linkedin" target="_blank">💼 LinkedIn</a>
                    </div>
                </div>
            </div>

            <!-- 作者签名档 -->
            <div class="author-signature">
                <div class="signature-content">
                    <h4>关于作者</h4>
                    <p><strong>周宜波</strong>，字节跳动火山引擎AI基础设施架构师，专注AI Agent、GPU池化、LLM推理优化等前沿技术。</p>
                    <div class="author-social">
                        <a href="https://twitter.com/zhyblife99" target="_blank">𝕏 Twitter</a>
                        <span class="wechat-hint">💬 关注微信公众号获取更多内容</span>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <!-- 侧边栏 -->
    <aside class="article-sidebar">
        <!-- 文章信息卡片 -->
        <div class="sidebar-card article-info-card">
            <h3>📊 文章信息</h3>
            <div class="info-list">
                <div class="info-item">
                    <span class="info-label">发布时间</span>
                    <span class="info-value">六 16 七月 2022</span>
                </div>
                <div class="info-item">
                    <span class="info-label">分类</span>
                    <span class="info-value">articles</span>
                </div>
                <div class="info-item">
                    <span class="info-label">预计阅读</span>
                    <span class="info-value">~10 分钟</span>
                </div>
            </div>
        </div>

        <!-- 相关文章推荐 -->
        <div class="sidebar-card related-articles-card">
            <h3>📚 相关文章</h3>
            <div class="related-list">
            </div>
        </div>

        <!-- 技术栈展示 -->
        <div class="sidebar-card skills-card">
            <h3>🚀 技术栈</h3>
            <div class="skills-list">
                <span class="skill-item">AI Agent</span>
                <span class="skill-item">GPU池化</span>
                <span class="skill-item">LLM推理优化</span>
                <span class="skill-item">高性能虚拟化</span>
            </div>
        </div>

        <!-- 关注公众号 -->
        <div class="sidebar-card wechat-card">
            <h3>🔔 订阅更新</h3>
            <div class="wechat-content">
                <p>扫码关注微信公众号</p>
                <img src="./images/qrcode.jpg" alt="微信公众号二维码" class="sidebar-qrcode">
                <p class="wechat-name">KernelNote</p>
            </div>
        </div>
    </aside>
</div>

<!-- 返回顶部按钮 -->
<button class="back-to-top" id="backToTop">
    <span>↑</span>
</button>

<script>
// 返回顶部功能
document.addEventListener('DOMContentLoaded', function() {
    const backToTop = document.getElementById('backToTop');

    // 监听滚动事件
    window.addEventListener('scroll', function() {
        if (window.pageYOffset > 300) {
            backToTop.style.display = 'block';
        } else {
            backToTop.style.display = 'none';
        }
    });

    // 点击返回顶部
    backToTop.addEventListener('click', function() {
        window.scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    });

    // 目录高亮
    const tocLinks = document.querySelectorAll('.toc-nav a');
    const headings = document.querySelectorAll('.article-content h2, .article-content h3, .article-content h4');

    function updateTocHighlight() {
        let current = '';
        headings.forEach((heading, index) => {
            const rect = heading.getBoundingClientRect();
            if (rect.top <= 100) {
                current = heading.id;
            }
        });

        tocLinks.forEach(link => {
            link.classList.remove('active');
            if (link.getAttribute('href') === '#' + current) {
                link.classList.add('active');
            }
        });
    }

    if (tocLinks.length > 0) {
        window.addEventListener('scroll', updateTocHighlight);
        updateTocHighlight();
    }

    // 平滑滚动到目录项
    tocLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
                targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        });
    });
});
</script>
                    </div>
                    <div class="span1"></div>
                </div>
            </div>
        </div>
<footer>




    <div id="fpowered">
        Powered by: <a href="http://getpelican.com/" title="Pelican Home Page" target="_blank" rel="nofollow noopener noreferrer">Pelican</a>
        Theme: <a href="https://elegant.oncrashreboot.com/" title="Theme Elegant Home Page" target="_blank" rel="nofollow noopener noreferrer">Elegant</a>
    </div>
</footer>        <script src="//code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>
    </body>
    <!-- Theme: Elegant built for Pelican
        License : MIT -->
</html>