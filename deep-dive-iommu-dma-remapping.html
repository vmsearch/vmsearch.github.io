<!DOCTYPE html>
<html lang="zh_cn">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="duma" />

        <meta name="description" content="序言 上一篇文章主要写了一下iommu硬件架构以及其在驱动层的初始化流程，那这一篇我们会花点时间来详细介绍一下iommu分别在虚拟化和非虚拟化场景下 dma remapping的工作原理 非虚拟化场景 在非虚拟化场景下如 …
" />
        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="iommu, articles, " />

<meta property="og:title" content="深入了解iommu系列二：iommu 工作原理解析之dma remapping "/>
<meta property="og:url" content="./deep-dive-iommu-dma-remapping.html" />
<meta property="og:description" content="序言 上一篇文章主要写了一下iommu硬件架构以及其在驱动层的初始化流程，那这一篇我们会花点时间来详细介绍一下iommu分别在虚拟化和非虚拟化场景下 dma remapping的工作原理 非虚拟化场景 在非虚拟化场景下如 …" />
<meta property="og:site_name" content="KernelNote - AI基础设施技术博客" />
<meta property="og:article:author" content="duma" />
<meta property="og:article:published_time" content="2022-02-06T00:00:00+08:00" />
<meta name="twitter:title" content="深入了解iommu系列二：iommu 工作原理解析之dma remapping ">
<meta name="twitter:description" content="序言 上一篇文章主要写了一下iommu硬件架构以及其在驱动层的初始化流程，那这一篇我们会花点时间来详细介绍一下iommu分别在虚拟化和非虚拟化场景下 dma remapping的工作原理 非虚拟化场景 在非虚拟化场景下如 …">

        <title>深入了解iommu系列二：iommu 工作原理解析之dma remapping  · KernelNote - AI基础设施技术博客
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="./theme/css/elegant.prod.css" media="screen">
        <link rel="stylesheet" type="text/css" href="./theme/css/custom.css" media="screen">

        <link href="https://kernelnote.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="KernelNote - AI基础设施技术博客 - Full Atom Feed" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LRRMJ08SPD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LRRMJ08SPD');
</script>



    </head>
    <body>
        <div id="content">
            <div class="navbar navbar-static-top">
                <div class="navbar-inner">
                    <div class="container-fluid">
                        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </a>
                        <a class="brand" href="./"><span class=site-name>KernelNote - AI基础设施技术博客</span></a>
                        <div class="nav-collapse collapse">
                            <ul class="nav pull-right top-menu">
                                <li >
                                    <a href=
                                       .
                                    >Home</a>
                                </li>
                                <li ><a href="./pages/about.html">about</a></li>
                                <li ><a href="./categories.html">Categories</a></li>
                                <li ><a href="./tags.html">Tags</a></li>
                                <li ><a href="./archives.html">Archives</a></li>
                                <li><form class="navbar-search" action="./search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container-fluid">
                <div class="row-fluid">
                    <div class="span1"></div>
                    <div class="span10">
<article itemscope>
<div class="row-fluid">
    <header class="page-header span10 offset2">
        <h1>
            <a href="./deep-dive-iommu-dma-remapping.html">
                深入了解iommu系列二：iommu 工作原理解析之dma remapping
            </a>
        </h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">
            
            <h3>序言</h3>
<p>上一篇文章主要写了一下iommu硬件架构以及其在驱动层的初始化流程，那这一篇我们会花点时间来详细介绍一下iommu分别在虚拟化和非虚拟化场景下 dma remapping的工作原理</p>
<h3>非虚拟化场景</h3>
<p>在非虚拟化场景下如果不是显示的在cmdline里面把iommu设置为disabled则一般都会默认enable iommu硬件，另外还有一种常用的方式就是iommu=pt这种方式跟default设置的唯一区别是会不会提前建立static map。为了让大家有个更清晰的认知，我们在内核里面找段dma操作相关的代码并以此为开端对iommu的dma工作机制进行剖析。</p>
<div class="highlight"><pre><span></span><code><span class="nx">static</span><span class="w"> </span><span class="nx">int</span><span class="w"> </span><span class="nx">e100_xmit_prepare</span><span class="p">(</span><span class="nx">struct</span><span class="w"> </span><span class="nx">nic</span><span class="w"> </span><span class="o">*</span><span class="nx">nic</span><span class="p">,</span><span class="w"> </span><span class="nx">struct</span><span class="w"> </span><span class="nx">cb</span><span class="w"> </span><span class="o">*</span><span class="nx">cb</span><span class="p">,</span>
<span class="w">        </span><span class="nx">struct</span><span class="w"> </span><span class="nx">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="nx">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="nx">dma_addr_t</span><span class="w"> </span><span class="nx">dma_addr</span><span class="p">;</span>
<span class="w">        </span><span class="nx">cb</span><span class="o">-&gt;</span><span class="nx">command</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">nic</span><span class="o">-&gt;</span><span class="nx">tx_command</span><span class="p">;</span>

<span class="w">        </span><span class="nx">dma_addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">pci_map_single</span><span class="p">(</span><span class="nx">nic</span><span class="o">-&gt;</span><span class="nx">pdev</span><span class="p">,</span>
<span class="w">                                  </span><span class="nx">skb</span><span class="o">-&gt;</span><span class="nx">data</span><span class="p">,</span><span class="w"> </span><span class="nx">skb</span><span class="o">-&gt;</span><span class="nx">len</span><span class="p">,</span><span class="w"> </span><span class="nx">PCI_DMA_TODEVICE</span><span class="p">);</span>
<span class="w">        </span><span class="cm">/* If we can&#39;t map the skb, have the upper layer try later */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">pci_dma_mapping_error</span><span class="p">(</span><span class="nx">nic</span><span class="o">-&gt;</span><span class="nx">pdev</span><span class="p">,</span><span class="w"> </span><span class="nx">dma_addr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">dev_kfree_skb_any</span><span class="p">(</span><span class="nx">skb</span><span class="p">);</span>
<span class="w">                </span><span class="nx">skb</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">NULL</span><span class="p">;</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="nx">ENOMEM</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="o">.........</span>
<span class="p">}</span>
</code></pre></div>

<p>上面的代码片断是摘至于内核e100网卡驱动，核心逻辑就是先把skb的地址做一下dma map，然后让硬件可以直接dma这段数据，其中使用的<code>pci_map_single</code>这个函数最终会调到</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">inline</span><span class="w"> </span><span class="n">dma_addr_t</span><span class="w"> </span><span class="n">dma_map_single_attrs</span><span class="p">(</span><span class="n">struct</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
<span class="w">                                              </span><span class="n">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                                              </span><span class="k">enum</span><span class="w"> </span><span class="n">dma_data_direction</span><span class="w"> </span><span class="n">dir</span><span class="p">,</span>
<span class="w">                                              </span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">struct</span><span class="w"> </span><span class="n">dma_map_ops</span><span class="w"> </span><span class="o">*</span><span class="n">ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_dma_ops</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="w">        </span><span class="n">dma_addr_t</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span>

<span class="w">        </span><span class="n">kmemcheck_mark_initialized</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">        </span><span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">valid_dma_direction</span><span class="p">(</span><span class="n">dir</span><span class="p">));</span>
<span class="w">        </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">map_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span>
<span class="w">                             </span><span class="n">offset_in_page</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                             </span><span class="n">dir</span><span class="p">,</span><span class="w"> </span><span class="n">attrs</span><span class="p">);</span>
<span class="w">        </span><span class="n">debug_dma_map_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span>
<span class="w">                           </span><span class="n">offset_in_page</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                           </span><span class="n">dir</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="bp">true</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>如果有iommu硬件的情况下(以intel iommu为例)他最终为走到<code>intel_map_page</code>，下面我们来看一下这个函数的核心逻辑</p>
<div class="highlight"><pre><span></span><code><span class="nx">static</span><span class="w"> </span><span class="nx">dma_addr_t</span><span class="w"> </span><span class="nx">__intel_map_single</span><span class="p">(</span><span class="nx">struct</span><span class="w"> </span><span class="nx">device</span><span class="w"> </span><span class="o">*</span><span class="nx">dev</span><span class="p">,</span><span class="w"> </span><span class="nx">phys_addr_t</span><span class="w"> </span><span class="nx">paddr</span><span class="p">,</span>
<span class="w">                                     </span><span class="nx">size_t</span><span class="w"> </span><span class="nx">size</span><span class="p">,</span><span class="w"> </span><span class="nx">int</span><span class="w"> </span><span class="nx">dir</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="nx">dma_mask</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="nx">struct</span><span class="w"> </span><span class="nx">dmar_domain</span><span class="w"> </span><span class="o">*</span><span class="nx">domain</span><span class="p">;</span>
<span class="w">        </span><span class="nx">phys_addr_t</span><span class="w"> </span><span class="nx">start_paddr</span><span class="p">;</span>
<span class="w">        </span><span class="nx">unsigned</span><span class="w"> </span><span class="nx">long</span><span class="w"> </span><span class="nx">iova_pfn</span><span class="p">;</span>
<span class="w">        </span><span class="nx">int</span><span class="w"> </span><span class="nx">prot</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="nx">int</span><span class="w"> </span><span class="nx">ret</span><span class="p">;</span>
<span class="w">        </span><span class="nx">struct</span><span class="w"> </span><span class="nx">intel_iommu</span><span class="w"> </span><span class="o">*</span><span class="nx">iommu</span><span class="p">;</span>
<span class="w">        </span><span class="nx">unsigned</span><span class="w"> </span><span class="nx">long</span><span class="w"> </span><span class="nx">paddr_pfn</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">paddr</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="nx">PAGE_SHIFT</span><span class="p">;</span>

<span class="w">        </span><span class="nx">BUG_ON</span><span class="p">(</span><span class="nx">dir</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">DMA_NONE</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">iommu_no_mapping</span><span class="p">(</span><span class="nx">dev</span><span class="p">))</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nx">paddr</span><span class="p">;</span>

<span class="w">        </span><span class="nx">domain</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">get_valid_domain_for_dev</span><span class="p">(</span><span class="nx">dev</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(!</span><span class="nx">domain</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="nx">iommu</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">domain_get_iommu</span><span class="p">(</span><span class="nx">domain</span><span class="p">);</span>
<span class="w">        </span><span class="nx">size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">aligned_nrpages</span><span class="p">(</span><span class="nx">paddr</span><span class="p">,</span><span class="w"> </span><span class="nx">size</span><span class="p">);</span>

<span class="w">        </span><span class="nx">iova_pfn</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">intel_alloc_iova</span><span class="p">(</span><span class="nx">dev</span><span class="p">,</span><span class="w"> </span><span class="nx">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">dma_to_mm_pfn</span><span class="p">(</span><span class="nx">size</span><span class="p">),</span><span class="w"> </span><span class="nx">dma_mask</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(!</span><span class="nx">iova_pfn</span><span class="p">)</span>
<span class="w">                </span><span class="nx">goto</span><span class="w"> </span><span class="nx">error</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Check if DMAR supports zero-length reads on write only</span>
<span class="cm">         * mappings..</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">dir</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">DMA_TO_DEVICE</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">dir</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">DMA_BIDIRECTIONAL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span>\
<span class="w">                        </span><span class="p">!</span><span class="nx">cap_zlr</span><span class="p">(</span><span class="nx">iommu</span><span class="o">-&gt;</span><span class="nx">cap</span><span class="p">))</span>
<span class="w">                </span><span class="nx">prot</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="nx">DMA_PTE_READ</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">dir</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">DMA_FROM_DEVICE</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">dir</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">DMA_BIDIRECTIONAL</span><span class="p">)</span>
<span class="w">                </span><span class="nx">prot</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="nx">DMA_PTE_WRITE</span><span class="p">;</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * paddr - (paddr + size) might be partial page, we should map the whole</span>
<span class="cm">         * page.  Note: if two part of one page are separately mapped, we</span>
<span class="cm">         * might have two guest_addr mapping to the same host paddr, but this</span>
<span class="cm">         * is not a big problem</span>
<span class="cm">         */</span>
<span class="w">         </span><span class="nx">ret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">domain_pfn_mapping</span><span class="p">(</span><span class="nx">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">mm_to_dma_pfn</span><span class="p">(</span><span class="nx">iova_pfn</span><span class="p">),</span>
<span class="w">                                 </span><span class="nx">mm_to_dma_pfn</span><span class="p">(</span><span class="nx">paddr_pfn</span><span class="p">),</span><span class="w"> </span><span class="nx">size</span><span class="p">,</span><span class="w"> </span><span class="nx">prot</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">ret</span><span class="p">)</span>
<span class="w">                </span><span class="nx">goto</span><span class="w"> </span><span class="nx">error</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* it&#39;s a non-present to present mapping. Only flush if caching mode */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">cap_caching_mode</span><span class="p">(</span><span class="nx">iommu</span><span class="o">-&gt;</span><span class="nx">cap</span><span class="p">))</span>
<span class="w">                </span><span class="nx">iommu_flush_iotlb_psi</span><span class="p">(</span><span class="nx">iommu</span><span class="p">,</span><span class="w"> </span><span class="nx">domain</span><span class="p">,</span>
<span class="w">                                      </span><span class="nx">mm_to_dma_pfn</span><span class="p">(</span><span class="nx">iova_pfn</span><span class="p">),</span>
<span class="w">                                      </span><span class="nx">size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">                </span><span class="nx">iommu_flush_write_buffer</span><span class="p">(</span><span class="nx">iommu</span><span class="p">);</span>

<span class="w">        </span><span class="nx">start_paddr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">phys_addr_t</span><span class="p">)</span><span class="nx">iova_pfn</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="nx">PAGE_SHIFT</span><span class="p">;</span>
<span class="w">        </span><span class="nx">start_paddr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">paddr</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="nx">PAGE_MASK</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">start_paddr</span><span class="p">;</span>

<span class="nx">error</span><span class="p">:</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">iova_pfn</span><span class="p">)</span>
<span class="w">                </span><span class="nx">free_iova_fast</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">iovad</span><span class="p">,</span><span class="w"> </span><span class="nx">iova_pfn</span><span class="p">,</span><span class="w"> </span><span class="nx">dma_to_mm_pfn</span><span class="p">(</span><span class="nx">size</span><span class="p">));</span>
<span class="w">        </span><span class="nx">pr_err</span><span class="p">(</span><span class="s">&quot;Device %s request: %zx@%llx dir %d --- failed\n&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="nx">dev_name</span><span class="p">(</span><span class="nx">dev</span><span class="p">),</span><span class="w"> </span><span class="nx">size</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">unsigned</span><span class="w"> </span><span class="nx">long</span><span class="w"> </span><span class="nx">long</span><span class="p">)</span><span class="nx">paddr</span><span class="p">,</span><span class="w"> </span><span class="nx">dir</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>我们来好好走读一下这个函数，首先会判断是否为<code>iommu_no_mapping</code>，如果是则直接返回paddr也即物理地址。再来看看<code>iommu_no_mapping</code>这个函数的具体逻辑。</p>
<div class="highlight"><pre><span></span><code>static int iommu_no_mapping(struct device <span class="gs">*dev)</span>
<span class="gs">{</span>
<span class="gs">        int found;</span>

<span class="gs">        if (iommu_dummy(dev))</span>
<span class="gs">                return 1;</span>

<span class="gs">        if (!iommu_identity_mapping)</span>
<span class="gs">                return 0;</span>

<span class="gs">        found = identity_mapping(dev);</span>
<span class="gs">        if (found) {</span>
<span class="gs">                if (iommu_should_identity_map(dev, 0))</span>
<span class="gs">                        return 1;</span>
<span class="gs">                else {</span>
<span class="gs">                        /*</span>
                         <span class="k">*</span> 32 bit DMA is removed from si_domain and fall back
                         <span class="k">*</span> to non-identity mapping.
                         <span class="gs">*/</span>
<span class="gs">                        dmar_remove_one_dev_info(si_domain, dev);</span>
<span class="gs">                        pr_info(&quot;32bit %s uses non-identity mapping\n&quot;,</span>
<span class="gs">                                dev_name(dev));</span>
<span class="gs">                        return 0;</span>
<span class="gs">                }</span>
<span class="gs">        } else {</span>
<span class="gs">                /*</span>
                 <span class="k">*</span> In case of a detached 64 bit DMA device from vm, the device
                 <span class="k">*</span> is put into si_domain for identity mapping.
                 */
                if (iommu_should_identity_map(dev, 0)) {
                        int ret;
                        ret = domain_add_dev_info(si_domain, dev);
                        if (!ret) {
                                pr_info(&quot;64bit %s uses identity mapping\n&quot;,
                                        dev_name(dev));
                                return 1;
                        }
                }
        }

        return 0;
}
</code></pre></div>

<p>从实现来看，首先会判断<code>iommu_identity_mapping</code>是否为空(如果大家读过上一篇文章应该知道当iommu=pt的时候这个变量是不会为空的)如果为空则返回false，这里我先看一下不为空的逻辑。接着函数走到<code>identity_mapping</code>，这个函数的实现具体如下：</p>
<div class="highlight"><pre><span></span><code>static int identity_mapping(struct device *dev)
{
        struct device_domain_info *info;

        if (likely(!iommu_identity_mapping))
                return 0;

        info = dev-&gt;archdata.iommu;
        if (info &amp;&amp; info != DUMMY_DEVICE_DOMAIN_INFO)
                return (info-&gt;domain == si_domain);

        return 0;
}
</code></pre></div>

<p>可以看到函数里面首先判断<code>iommu_identity_mapping</code>是否为空，那么在iommut=pt的情况下这个是不为空的，然后判断设备的domain是否为si_domain，当然这个答案也是肯定的。因此这个函数返回值为true，接着函数走到<code>iommu_should_identity_map(dev, 0)</code>，那么这个函数主要的判断如下：</p>
<ol>
<li>如果这个设备不是pci设备且这个设备有RMRR，则这返回False.</li>
<li>如果这个设备是pci设备，则下面几种情况会返回False：<ul>
<li>这个pci设备有rmrr</li>
<li><code>iommu_identity_mapping</code> 的值不是IDENTMAP_ALL</li>
<li>是pci设备但不是pcie设备，则如果设备不是 root bus 或者说pci设备的种类是pci bridge</li>
<li>是pcie设备且pcie 设备是pcie bridge</li>
</ul>
</li>
<li>如果这个设备是32bit的设备则返回false</li>
</ol>
<p>如果这个函数返回false则需要从si_domain里面把这个设备的mapping删除掉，如果返回True则直接返回物理地址。所以总结一下在iommu=pt的场景下，由于静态映射的存在所以直接返回paddr。为什么能够直接返回物理地址而不是iova呢？这里我们再详细的介绍一下，我们先来看一下<code>si_domain</code>的初始化：</p>
<div class="highlight"><pre><span></span><code>static int __init si_domain_init(int hw)
{
        int nid, ret = 0;

        si_domain = alloc_domain(DOMAIN_FLAG_STATIC_IDENTITY);
        if (!si_domain)
                return -EFAULT;

        if (md_domain_init(si_domain, DEFAULT_DOMAIN_ADDRESS_WIDTH)) {
                domain_exit(si_domain);
                return -EFAULT;
        }

        pr_debug(&quot;Identity mapping domain allocated\n&quot;);
        //如果hw为true,则直接返回
        if (hw)
                return 0;

        for_each_online_node(nid) {
                unsigned long start_pfn, end_pfn;
                int i;

                for_each_mem_pfn_range(i, nid, &amp;start_pfn, &amp;end_pfn, NULL) {
                        ret = iommu_domain_identity_map(si_domain,
                                        PFN_PHYS(start_pfn), PFN_PHYS(end_pfn));
                        if (ret)
                                return ret;
                }
        }

        return 0;
}
</code></pre></div>

<p>首先，hw这个参数输入为hw_pass_through，它指的是iommu硬件上是否支持paas through翻译模式即iova就是真实的物理地址不需要再走一遍从iova转换到hpa的流程。那么从上面的函数实现也能看到如果hw为true则si_domain不会再去做相关内存mapping(关于hw为false的情况后面我们再分析），也就是说如果iommu硬件支持hw且iommu配置了pt则这种场景下硬件的DMA到达iommu之后不需要走页表翻译直接跟memory controller进行交互就可以了。<strong>但是大家再仔细想一下iommu硬件是如何知道哪些设备的dma要走页表进行转换，哪些设备的dma不需要进行地址转换呢？</strong> 为了更好的解释这个问题，我们先来回忆一下dma的页表是如何确定的</p>
<p><img alt="iotlb" src="images/iotlb.png"></p>
<center>图1</center>
<p>从上面这张图我们可以看到一个设备的iova页表首先是通过bus号在root table里面找到相应的root_entry，然后再通过devfn在context table里面找到对应的context_entry，然后才能找到真正的页表。从vt-d的spec来看，contex_entry的format里面有一个标志位(TT)来表明这个设备的DMA是否是paasthroug，具体如下:</p>
<p><img alt="contex_entry" src="images/contex_entry.png"></p>
<center>图2</center>

<p>我们再来看一下对图2中相关字段的详细描述：</p>
<p><img alt="tt" src="images/tt.png"></p>
<center>图3</center>
<p>从图3中可以看到TT这个字段为10b时表示这个dma是不需要进行页表转换的，所以<strong>iommu就是通过这个字段来进行区分是否要通过页表进行转换的</strong>。但是还有一个问题是这个TT为paasthrough的translation type是什么时候设置的？回答这个问题，我们还是需要回归到内核相关代码当中。目前我们条件是hw为true，且iommu=pt的情况，我们还是回到<code>intel_iommu_init</code>的这个函数当中</p>
<div class="highlight"><pre><span></span><code>        if (iommu_identity_mapping) {
                ret = iommu_prepare_static_identity_mapping(hw_pass_through);
                if (ret) {
                        pr_crit(&quot;Failed to setup IOMMU pass-through\n&quot;);
                        goto free_iommu;
                }
        }
</code></pre></div>

<p>上面这个函数片断截取自<code>init_dmars</code>这个函数，其核心函数为<code>iommu_prepare_static_identity_mapping</code>，它最终会调到<code>domain_add_dev_info</code> 这个函数并最终走到<code>domain_context_mapping_one</code></p>
<div class="highlight"><pre><span></span><code><span class="nx">static</span><span class="w"> </span><span class="nx">int</span><span class="w"> </span><span class="nx">domain_context_mapping_one</span><span class="p">(</span><span class="nx">struct</span><span class="w"> </span><span class="nx">dmar_domain</span><span class="w"> </span><span class="o">*</span><span class="nx">domain</span><span class="p">,</span>
<span class="w">                                      </span><span class="nx">struct</span><span class="w"> </span><span class="nx">intel_iommu</span><span class="w"> </span><span class="o">*</span><span class="nx">iommu</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">u8</span><span class="w"> </span><span class="nx">bus</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="nx">devfn</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="o">......</span>
<span class="w">    </span><span class="c1">//设置translation type 为 paas through</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">hw_pass_through</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">domain_type_is_si</span><span class="p">(</span><span class="nx">domain</span><span class="p">))</span>
<span class="w">                </span><span class="nx">translation</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">CONTEXT_TT_PASS_THROUGH</span><span class="p">;</span>
<span class="w">    </span><span class="o">......</span>
<span class="w">    </span><span class="c1">//获取这个设备在contex table表里面的地址</span>
<span class="w">    </span><span class="nx">context</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">iommu_context_addr</span><span class="p">(</span><span class="nx">iommu</span><span class="p">,</span><span class="w"> </span><span class="nx">bus</span><span class="p">,</span><span class="w"> </span><span class="nx">devfn</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(!</span><span class="nx">context</span><span class="p">)</span>
<span class="w">           </span><span class="nx">goto</span><span class="w"> </span><span class="nx">out_unlock</span><span class="p">;</span>

<span class="w">     </span><span class="nx">ret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">context_present</span><span class="p">(</span><span class="nx">context</span><span class="p">))</span>
<span class="w">            </span><span class="nx">goto</span><span class="w"> </span><span class="nx">out_unlock</span><span class="p">;</span>

<span class="w">      </span><span class="nx">pgd</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">pgd</span><span class="p">;</span><span class="w"> </span><span class="c1">//iova页表基址</span>

<span class="w">      </span><span class="nx">context_clear_entry</span><span class="p">(</span><span class="nx">context</span><span class="p">);</span>
<span class="w">      </span><span class="nx">context_set_domain_id</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">did</span><span class="p">);</span>

<span class="w">    </span><span class="o">......</span><span class="p">.</span>
<span class="w">    </span><span class="c1">//下面函数可以看出如果是在paas through模式下不会设置iova页表地址</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">translation</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">CONTEXT_TT_PASS_THROUGH</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">agaw</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">agaw</span><span class="p">;</span><span class="w"> </span><span class="nx">agaw</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">iommu</span><span class="o">-&gt;</span><span class="nx">agaw</span><span class="p">;</span><span class="w"> </span><span class="nx">agaw</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="nx">ret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">-</span><span class="nx">ENOMEM</span><span class="p">;</span>
<span class="w">                        </span><span class="nx">pgd</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">phys_to_virt</span><span class="p">(</span><span class="nx">dma_pte_addr</span><span class="p">(</span><span class="nx">pgd</span><span class="p">));</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(!</span><span class="nx">dma_pte_present</span><span class="p">(</span><span class="nx">pgd</span><span class="p">))</span>
<span class="w">                                </span><span class="nx">goto</span><span class="w"> </span><span class="nx">out_unlock</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="nx">info</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">iommu_support_dev_iotlb</span><span class="p">(</span><span class="nx">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">iommu</span><span class="p">,</span><span class="w"> </span><span class="nx">bus</span><span class="p">,</span><span class="w"> </span><span class="nx">devfn</span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">info</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">info</span><span class="o">-&gt;</span><span class="nx">ats_supported</span><span class="p">)</span>
<span class="w">                        </span><span class="nx">translation</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">CONTEXT_TT_DEV_IOTLB</span><span class="p">;</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                        </span><span class="nx">translation</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">CONTEXT_TT_MULTI_LEVEL</span><span class="p">;</span>

<span class="w">                </span><span class="c1">//非paas through模式下需要设置iova页表的基地址</span>
<span class="w">                </span><span class="nx">context_set_address_root</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">virt_to_phys</span><span class="p">(</span><span class="nx">pgd</span><span class="p">));</span>
<span class="w">                </span><span class="nx">context_set_address_width</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">iommu</span><span class="o">-&gt;</span><span class="nx">agaw</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/*</span>
<span class="cm">                 * In pass through mode, AW must be programmed to</span>
<span class="cm">                 * indicate the largest AGAW value supported by</span>
<span class="cm">                 * hardware. And ASR is ignored by hardware.</span>
<span class="cm">                 */</span>
<span class="w">                </span><span class="nx">context_set_address_width</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">iommu</span><span class="o">-&gt;</span><span class="nx">msagaw</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 设置转换类型</span>
<span class="w">        </span><span class="nx">context_set_translation_type</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">translation</span><span class="p">)</span>

<span class="p">}</span>
</code></pre></div>

<p>看完之后大家应该有个比较清晰的理解，上面主要理了一下在iommu=pt，hw为true的情况；如果hw为false的情况又会怎么样了？具体的逻辑还是要从<code>init_dmars</code>这个函数开始看起，通过分析可以看到因为hw=false也就是说iommu硬件不支持paas through 的translation type，所以必须要是创建页表的，但是因为是静态映射即iova就等于hpa，所以在这种情况下也是可以直接返回paddr的，但是效率肯定是没法跟hw=true相比的。</p>
<p>聊完iommu=pt的各种情况之后，我们再看一下iommu为默认设置的情况下设备是如何进行dma操作的。 还是先要从<code>intel_iommu_init</code>这个函数里面的<code>init_dmars</code>看起，从这相关的逻辑来看区别在于不会提前创建si_domain(即提前做好iova的映射)，那它是在什么时候创建的呢？答案是在dma_map的时候而且dma map相关的api返回的iova，如果大家感兴趣可以去仔细读一下<code>__intel_map_single</code>这个函数，部分核心逻辑如下：</p>
<div class="highlight"><pre><span></span><code><span class="w">        </span><span class="c1">//如果dev没有创建domain则重新创建，同时将其加入到contex table里面</span>
<span class="w">        </span><span class="nx">domain</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">get_valid_domain_for_dev</span><span class="p">(</span><span class="nx">dev</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(!</span><span class="nx">domain</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="nx">iommu</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">domain_get_iommu</span><span class="p">(</span><span class="nx">domain</span><span class="p">);</span>
<span class="w">        </span><span class="nx">size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">aligned_nrpages</span><span class="p">(</span><span class="nx">paddr</span><span class="p">,</span><span class="w"> </span><span class="nx">size</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//分配iova</span>
<span class="w">        </span><span class="nx">iova_pfn</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">intel_alloc_iova</span><span class="p">(</span><span class="nx">dev</span><span class="p">,</span><span class="w"> </span><span class="nx">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">dma_to_mm_pfn</span><span class="p">(</span><span class="nx">size</span><span class="p">),</span><span class="w"> </span><span class="nx">dma_mask</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(!</span><span class="nx">iova_pfn</span><span class="p">)</span>
<span class="w">                </span><span class="nx">goto</span><span class="w"> </span><span class="nx">error</span><span class="p">;</span>
</code></pre></div>

<h3>虚拟化场景</h3>
<p>iommu在虚拟化场景扮演着非常重要的作用，尤其是在设备直通的场景。大家都知道在虚拟机里面是没有iommu的，guest 里面的所有的dma_ops走的都是noiommu(当然之前也有人在推viommu的方案)，所以当你在guest里面使用dma_map这种类似的api的时候，其返回的都是gpa。这样问题就来了，你想想如果虚拟机使用的是virtio-net or virtio-blk这种完全模拟的设备还好，因为其本质都还是共享内存还是在mmu层做转换。但是在直通设备的场景下，它就是跟真的外设打交道，而外设是无法直接dma gpa的，它必然要做一层转换。接下来我们就来分析一下虚拟化场景下iommu是如何工作的。</p>
<p>首先，如果你要在虚拟机场景下做设备直通那我们经常会在kernel cmdline里面做iommu=pt, intel_iommu=on(当然也可以是amd, arm)。然后把vf或者pf从原来的驱动unbind掉，然后bind到<code>vfio_pci</code>，接着在启动虚拟机的时候我们需要对设备在vfio层面进行相关的初始化，然后并对guest所有的内存做vfio_dma_map。iommu=pt这个由于前面已经分析过了，这里我就不再细讲，我们看一下把vf或者pf从原来的驱动unbind的过程中跟iommu相关的哪些：</p>
<div class="highlight"><pre><span></span><code><span class="nx">static</span><span class="w"> </span><span class="nx">int</span><span class="w"> </span><span class="nx">device_notifier</span><span class="p">(</span><span class="nx">struct</span><span class="w"> </span><span class="nx">notifier_block</span><span class="w"> </span><span class="o">*</span><span class="nx">nb</span><span class="p">,</span>
<span class="w">                                  </span><span class="nx">unsigned</span><span class="w"> </span><span class="nx">long</span><span class="w"> </span><span class="nx">action</span><span class="p">,</span><span class="w"> </span><span class="nx">void</span><span class="w"> </span><span class="o">*</span><span class="nx">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="nx">struct</span><span class="w"> </span><span class="nx">device</span><span class="w"> </span><span class="o">*</span><span class="nx">dev</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">data</span><span class="p">;</span>
<span class="w">        </span><span class="nx">struct</span><span class="w"> </span><span class="nx">dmar_domain</span><span class="w"> </span><span class="o">*</span><span class="nx">domain</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">iommu_dummy</span><span class="p">(</span><span class="nx">dev</span><span class="p">))</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">action</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">BUS_NOTIFY_REMOVED_DEVICE</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="nx">domain</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">find_domain</span><span class="p">(</span><span class="nx">dev</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(!</span><span class="nx">domain</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="nx">dmar_remove_one_dev_info</span><span class="p">(</span><span class="nx">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">dev</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(!</span><span class="nx">domain_type_is_vm_or_si</span><span class="p">(</span><span class="nx">domain</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">devices</span><span class="p">))</span>
<span class="w">                </span><span class="nx">domain_exit</span><span class="p">(</span><span class="nx">domain</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">static</span><span class="w"> </span><span class="nx">struct</span><span class="w"> </span><span class="nx">notifier_block</span><span class="w"> </span><span class="nx">device_nb</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="nx">notifier_call</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">device_notifier</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>

<p>这个是比较核心的地方，从上面的逻辑可以看出设备从其原来的driver unbind的时候会如果这个设备已经有了相关的dmar_domain比如之前说的在pt的场景下会提前创建好静态mapping si_domain，那么这时候会把设备从si_domain移除。</p>
<p>然后再看把设备bind到vfio-pci driver的时候发生了什么事情呢？最终其会调到<code>vfio_pci_probe</code>这个函数里面，其核心的逻辑具体如下：</p>
<ul>
<li><code>vfio_iommu_group_get</code></li>
</ul>
<p>这个函数主要是判断这个设备是否属于某个iommu_group，如果没有则报错。</p>
<ul>
<li><code>vfio_add_group_dev</code></li>
</ul>
<p>这个函数首先从该设备所属的iommu_group找到相应的<code>vfio_group</code>，如果找不到则会为这个<code>iommu_group</code>创建<code>vfio_group</code>；然后再把这个dev跟<code>vfio_device</code>关联起来，同时为这个<code>vfio_dev</code>绑定<code>vfio_device_ops</code></p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="n">vfio_device_ops</span><span class="w"> </span><span class="n">vfio_pci_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">.</span><span class="n">name</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;vfio-pci&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="o">.</span><span class="n">open</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">vfio_pci_open</span><span class="p">,</span>
<span class="w">        </span><span class="o">.</span><span class="n">release</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">vfio_pci_release</span><span class="p">,</span>
<span class="w">        </span><span class="o">.</span><span class="n">ioctl</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">vfio_pci_ioctl</span><span class="p">,</span>
<span class="w">        </span><span class="o">.</span><span class="n">read</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">vfio_pci_read</span><span class="p">,</span>
<span class="w">        </span><span class="o">.</span><span class="n">write</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">vfio_pci_write</span><span class="p">,</span>
<span class="w">        </span><span class="o">.</span><span class="n">mmap</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">vfio_pci_mmap</span><span class="p">,</span>
<span class="w">        </span><span class="o">.</span><span class="n">request</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">vfio_pci_request</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>

<p>上面我们主要是聊了一下设备直通之前的一些准备工作，下面我们看一下qemu侧直通设备vfio相关的操作，为了让大家更的好理解我们举个例子，假设我们要把pci device 0000:06:0d.0 直通给vm，则看一下相关的信息：</p>
<blockquote>
<p>readlink /sys/bus/pci/devices/0000:06:0d.0/iommu_group</p>
<p>../../../../kernel/iommu_groups/26</p>
</blockquote>
<p>然后我们来看一下qemu侧vfio设备的初始操作函数vfio_realize，相关的逻辑如下：</p>
<ul>
<li>vfio_get_group</li>
</ul>
<blockquote>
<p>snprintf(path, sizeof(path), "/dev/vfio/%d", groupid);</p>
<p>group-&gt;fd = qemu_open(path, O_RDWR);</p>
</blockquote>
<p>首先打开这个group，以上面的device为例子则这个groupid为26，这个open函数对应的是ops函数如下:</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="n">file_operations</span><span class="w"> </span><span class="n">vfio_group_fops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">.</span><span class="n">owner</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="w">        </span><span class="o">.</span><span class="n">unlocked_ioctl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vfio_group_fops_unl_ioctl</span><span class="p">,</span>
<span class="c1">#ifdef CONFIG_COMPAT</span>
<span class="w">        </span><span class="o">.</span><span class="n">compat_ioctl</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">vfio_group_fops_compat_ioctl</span><span class="p">,</span>
<span class="c1">#endif</span>
<span class="w">        </span><span class="o">.</span><span class="n">open</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">vfio_group_fops_open</span><span class="p">,</span>
<span class="w">        </span><span class="o">.</span><span class="n">release</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">vfio_group_fops_release</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>

<p><code>vfio_group_fops_open</code>函数核心逻辑就是要找到这个设备所属于的<code>vfio_group</code>并把它赋给这个file，那这个<code>vfio_group</code>是在设备bind到<code>vfio_pci</code>的时候创建的。紧接着会判断这个设备的vfio group是否可用，相关逻辑如下：</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="kr">group</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">VFIO_GROUP_GET_STATUS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">status</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">error_setg_errno</span><span class="p">(</span><span class="n">errp</span><span class="p">,</span><span class="w"> </span><span class="n">errno</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;failed to get group %d status&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">groupid</span><span class="p">);</span>
<span class="w">        </span><span class="n">goto</span><span class="w"> </span><span class="n">close_fd_exit</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VFIO_GROUP_FLAGS_VIABLE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">error_setg</span><span class="p">(</span><span class="n">errp</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;group %d is not viable&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">groupid</span><span class="p">);</span>
<span class="w">        </span><span class="n">error_append_hint</span><span class="p">(</span><span class="n">errp</span><span class="p">,</span>
<span class="w">                          </span><span class="s">&quot;Please ensure all devices within the iommu_group &quot;</span>
<span class="w">                          </span><span class="s">&quot;are bound to their vfio bus driver.\n&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">goto</span><span class="w"> </span><span class="n">close_fd_exit</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<p>通过ioctl调到vfio模块当中，具体的逻辑如下：</p>
<div class="highlight"><pre><span></span><code><span class="w">   </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">vfio_group_viable</span><span class="p">(</span><span class="kr">group</span><span class="p">))</span>
<span class="w">            </span><span class="n">status</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">VFIO_GROUP_FLAGS_VIABLE</span><span class="p">;</span>

<span class="w">    </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="kr">group</span><span class="o">-&gt;</span><span class="n">container</span><span class="p">)</span>
<span class="w">             </span><span class="n">status</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">VFIO_GROUP_FLAGS_CONTAINER_SET</span><span class="p">;</span>
</code></pre></div>

<p>紧接着会调用<code>vfio_connect_container</code>， 这个container是vfio层面的一个概念，它跟vm的address space相关联，这个函数的具体逻辑如下：</p>
<ul>
<li>
<p>如果container存在，则直接调用<code>VFIO_GROUP_SET_CONTAINER</code> 这个ioctl将这个设备所属的vfio_group跟这个containe关联起来，具体这个ioctl到底做了哪些事情，我们后面再详细说</p>
</li>
<li>
<p>如果container不存在，则需要先创建出来，具体的创建逻辑如下</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code>fd = qemu_open(&quot;/dev/vfio/vfio&quot;, O_RDWR);
</code></pre></div>

<p>这个container就是这在个时候创建出来的，它在vfio层调用的是vfio_ops的open函数，具体如下：</p>
<div class="highlight"><pre><span></span><code>static int vfio_fops_open(struct inode *inode, struct file *filep)
{
        struct vfio_container *container;

        container = kzalloc(sizeof(*container), GFP_KERNEL);
        if (!container)
                return -ENOMEM;

        INIT_LIST_HEAD(&amp;container-&gt;group_list);
        init_rwsem(&amp;container-&gt;group_lock);
        kref_init(&amp;container-&gt;kref);

        filep-&gt;private_data = container;

        return 0;
}
</code></pre></div>

<p>接着调用<code>vfio_init_container</code>函数，首先去获取一下<code>iommu_type</code>，目前的逻辑是<code>VFIO_TYPE1v2_IOMMU</code>优先(在driver/vfio/vfio_iommu_type1.c)，然后通过<code>VFIO_GROUP_SET_CONTAINER</code>这个ioctl具体做的事情。它最终会调到<code>vfio_group_set_container</code> 这个函数，其核心逻辑如下:</p>
<div class="highlight"><pre><span></span><code><span class="w">        </span><span class="n">driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container</span><span class="o">-&gt;</span><span class="n">iommu_driver</span><span class="p">;</span>
<span class="w">        </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">driver</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">attach_group</span><span class="p">(</span><span class="n">container</span><span class="o">-&gt;</span><span class="n">iommu_data</span><span class="p">,</span>
<span class="w">                                                </span><span class="kr">group</span><span class="o">-&gt;</span><span class="n">iommu_group</span><span class="p">);</span>
<span class="w">                </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="w">                        </span><span class="n">goto</span><span class="w"> </span><span class="n">unlock_out</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
</code></pre></div>

<p>注意这个时候由于driver目前还没有设置所以为空，故这个函数主要的作用就是把这个设备所属的vfio_group跟这个container关联起来，然后将这个vfio_group添加到container的group_list。接着调用<code>VFIO_SET_IOMMU</code>这个ioctl为这个container做相关配置，入口函数为<code>vfio_ioctl_set_iommu</code>具体逻辑如下：</p>
<ul>
<li>
<p><code>vfio_iommu_type1_open</code>
创建一个<code>vfio_iommu</code>，并初始化这个<code>vfio_iommu</code> 的<code>domain_list</code>，初始化这个iommu的<code>dma_list</code>为RB_ROOT。</p>
</li>
<li>
<p><code>__vfio_container_attach_groups</code></p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="nt">static</span><span class="w"> </span><span class="nt">int</span><span class="w"> </span><span class="nt">__vfio_container_attach_groups</span><span class="o">(</span><span class="nt">struct</span><span class="w"> </span><span class="nt">vfio_container</span><span class="w"> </span><span class="o">*</span><span class="nt">container</span><span class="o">,</span>
<span class="w">                                          </span><span class="nt">struct</span><span class="w"> </span><span class="nt">vfio_iommu_driver</span><span class="w"> </span><span class="o">*</span><span class="nt">driver</span><span class="o">,</span>
<span class="w">                                          </span><span class="nt">void</span><span class="w"> </span><span class="o">*</span><span class="nt">data</span><span class="o">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="err">struct</span><span class="w"> </span><span class="err">vfio_group</span><span class="w"> </span><span class="err">*group</span><span class="p">;</span>
<span class="w">        </span><span class="err">int</span><span class="w"> </span><span class="err">ret</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">-ENODEV</span><span class="p">;</span>

<span class="w">        </span><span class="err">list_for_each_entry(group,</span><span class="w"> </span><span class="err">&amp;container-&gt;group_list,</span><span class="w"> </span><span class="err">container_next)</span><span class="w"> </span><span class="err">{</span>
<span class="w">                </span><span class="err">ret</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">driver-&gt;ops-&gt;attach_group(data,</span><span class="w"> </span><span class="err">group-&gt;iommu_group)</span><span class="p">;</span>
<span class="w">                </span><span class="err">if</span><span class="w"> </span><span class="err">(ret)</span>
<span class="w">                        </span><span class="err">goto</span><span class="w"> </span><span class="err">unwind</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nt">return</span><span class="w"> </span><span class="nt">ret</span><span class="o">;</span>

<span class="nt">unwind</span><span class="o">:</span>
<span class="w">        </span><span class="nt">list_for_each_entry_continue_reverse</span><span class="o">(</span><span class="nt">group</span><span class="o">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nt">container-</span><span class="o">&gt;</span><span class="nt">group_list</span><span class="o">,</span>
<span class="w">                                             </span><span class="nt">container_next</span><span class="o">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="err">driver-&gt;ops-&gt;detach_group(data,</span><span class="w"> </span><span class="err">group-&gt;iommu_group)</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nt">return</span><span class="w"> </span><span class="nt">ret</span><span class="o">;</span>
<span class="err">}</span>
</code></pre></div>

<p>从实现来看，遍历<code>container-&gt;group_list</code>里面的group（这个时候应该只有一个)，然后调用<code>attach_group</code> 这个callback函数，其最终调用的函数为<code>vfio_iommu_type1_attach_group</code> ，下面看一下这个函数核心逻辑：</p>
<ol>
<li>
<p>首先遍历传入的参数1也就是<code>vfio_iommu</code>的<code>domain_list</code>每一个<code>vfio_domain</code>，然后遍历每个<code>vfio_domain-&gt;group_list</code>当中的<code>vfio_group</code>，判断该设备所属于的<code>iommu_group</code>已经attach过。</p>
</li>
<li>
<p>如果step1里面没有找到，则新建<code>vfio_group</code>和<code>vfio_domain</code>，并把<code>vfio_group-&gt;iommu_group</code>指向该设备所属的iommu_group</p>
</li>
<li>
<p>判断该设备的<code>iommu_group</code>下的每个设备的bus type是否为vfio bus。</p>
</li>
<li>
<p>通过<code>iommu_domain_alloc</code>为新建的vfio_domain创新的<code>iommu_domain</code>，其最终调用的函数为<code>intel_iommu_domain_alloc</code> </p>
</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="nx">static</span><span class="w"> </span><span class="nx">struct</span><span class="w"> </span><span class="nx">iommu_domain</span><span class="w"> </span><span class="o">*</span><span class="nx">intel_iommu_domain_alloc</span><span class="p">(</span><span class="nx">unsigned</span><span class="w"> </span><span class="k">type</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="nx">struct</span><span class="w"> </span><span class="nx">dmar_domain</span><span class="w"> </span><span class="o">*</span><span class="nx">dmar_domain</span><span class="p">;</span>
<span class="w">        </span><span class="nx">struct</span><span class="w"> </span><span class="nx">iommu_domain</span><span class="w"> </span><span class="o">*</span><span class="nx">domain</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">IOMMU_DOMAIN_UNMANAGED</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nx">NULL</span><span class="p">;</span>

<span class="w">        </span><span class="nx">dmar_domain</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">alloc_domain</span><span class="p">(</span><span class="nx">DOMAIN_FLAG_VIRTUAL_MACHINE</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(!</span><span class="nx">dmar_domain</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">pr_err</span><span class="p">(</span><span class="s">&quot;Can&#39;t allocate dmar_domain\n&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nx">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">md_domain_init</span><span class="p">(</span><span class="nx">dmar_domain</span><span class="p">,</span><span class="w"> </span><span class="nx">DEFAULT_DOMAIN_ADDRESS_WIDTH</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">pr_err</span><span class="p">(</span><span class="s">&quot;Domain initialization failed\n&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="nx">domain_exit</span><span class="p">(</span><span class="nx">dmar_domain</span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nx">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">domain_update_iommu_cap</span><span class="p">(</span><span class="nx">dmar_domain</span><span class="p">);</span>

<span class="w">        </span><span class="nx">domain</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">dmar_domain</span><span class="o">-&gt;</span><span class="nx">domain</span><span class="p">;</span>
<span class="w">        </span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">geometry</span><span class="p">.</span><span class="nx">aperture_start</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">geometry</span><span class="p">.</span><span class="nx">aperture_end</span><span class="w">   </span><span class="p">=</span><span class="w"> </span><span class="nx">__DOMAIN_MAX_ADDR</span><span class="p">(</span><span class="nx">dmar_domain</span><span class="o">-&gt;</span><span class="nx">gaw</span><span class="p">);</span>
<span class="w">        </span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">geometry</span><span class="p">.</span><span class="nx">force_aperture</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">domain</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>其核心逻辑为创建dmar_domain，然后初始化iova页表的pgd</p>
<div class="highlight"><pre><span></span><code><span class="nx">static</span><span class="w"> </span><span class="nx">int</span><span class="w"> </span><span class="nx">md_domain_init</span><span class="p">(</span><span class="nx">struct</span><span class="w"> </span><span class="nx">dmar_domain</span><span class="w"> </span><span class="o">*</span><span class="nx">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">int</span><span class="w"> </span><span class="nx">guest_width</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="nx">int</span><span class="w"> </span><span class="nx">adjust_width</span><span class="p">;</span>

<span class="w">        </span><span class="nx">init_iova_domain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">iovad</span><span class="p">,</span><span class="w"> </span><span class="nx">VTD_PAGE_SIZE</span><span class="p">,</span><span class="w"> </span><span class="nx">IOVA_START_PFN</span><span class="p">);</span>
<span class="w">        </span><span class="nx">domain_reserve_special_ranges</span><span class="p">(</span><span class="nx">domain</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* calculate AGAW */</span>
<span class="w">        </span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">gaw</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">guest_width</span><span class="p">;</span>
<span class="w">        </span><span class="nx">adjust_width</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">guestwidth_to_adjustwidth</span><span class="p">(</span><span class="nx">guest_width</span><span class="p">);</span>
<span class="w">        </span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">agaw</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">width_to_agaw</span><span class="p">(</span><span class="nx">adjust_width</span><span class="p">);</span>

<span class="w">        </span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">iommu_coherency</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">iommu_snooping</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">iommu_superpage</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">max_addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* always allocate the top pgd */</span>
<span class="w">        </span><span class="c1">//dma进行转换的页表基地址，可以参考图1</span>
<span class="w">        </span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">pgd</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">struct</span><span class="w"> </span><span class="nx">dma_pte</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nx">alloc_pgtable_page</span><span class="p">(</span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">nid</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(!</span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">pgd</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="nx">ENOMEM</span><span class="p">;</span>
<span class="w">        </span><span class="nx">domain_flush_cache</span><span class="p">(</span><span class="nx">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">domain</span><span class="o">-&gt;</span><span class="nx">pgd</span><span class="p">,</span><span class="w"> </span><span class="nx">PAGE_SIZE</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>紧接着调用 <code>iommu_attach_group</code>，将<code>iommu_group</code>下面的设备绑定到新建的iommu_domain上，函数最终会调到<code>intel_iommu_attach_device</code> 这个函数，具体的调用逻辑如下：</p>
<blockquote>
<ul>
<li><code>intel_iommu_attach_device</code></li>
<li><code>domain_add_dev_info</code>
        - <code>dmar_insert_one_dev_info</code>
           - <code>domain_attach_iommu</code>
           - <code>domain_context_mapping</code>
               - <code>domain_context_mapping_one</code></li>
</ul>
</blockquote>
<p>主要实现的就是把context table建立起来，并设置相关的context entry的属性等。然后初始化这个<code>vfio_domain</code>的<code>group_list</code>，并把这个vfio_group添加到这个这个group当中。</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">group_list</span><span class="p">);</span>
<span class="w">    </span><span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">group</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">group_list</span><span class="p">)</span>
</code></pre></div>

<p>接着往下看相关的逻辑</p>
<div class="highlight"><pre><span></span><code><span class="w">        </span><span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_list</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">ops</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">ops</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">                    </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">prot</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">prot</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">iommu_detach_group</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span><span class="w"> </span><span class="n">iommu_group</span><span class="p">);</span>
<span class="w">                        </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">iommu_attach_group</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span><span class="w"> </span><span class="n">iommu_group</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                                </span><span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">group</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">group_list</span><span class="p">);</span>
<span class="w">                                </span><span class="n">iommu_domain_free</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
<span class="w">                                </span><span class="n">kfree</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
<span class="w">                                </span><span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">                                </span><span class="kr">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span>

<span class="w">                        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iommu_attach_group</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span><span class="w"> </span><span class="n">iommu_group</span><span class="p">);</span>
<span class="w">                        </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="w">                                </span><span class="n">goto</span><span class="w"> </span><span class="n">out_domain</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
</code></pre></div>

<p>为了更好的理解上面的这段逻辑，先回忆下这几个概念：container, vfio_iommu, vfio_group, <code>vfio_domain</code>。其中container是per vm的也就是说一个vm只会有一个container；<code>vfio_iommu</code>是在container初始化的时候创建的，它也是per vm的；<code>vfio_group</code>跟<code>iommu_group</code>是一一对应的，有多少个<code>iommu_group</code>就应该有多少个<code>vfio_group</code>；关于<code>vfio_domain</code>数量我们需要分析一下上面的代码片段，从实现来看<strong>如果新创建的domain的ops和prot(属性IOMMU_CACHE, IOMMU_READ, IOMMU_WRITE)跟已经存在的domain相同则直接把这个iommu_group直接attach到已存在的domain上，也就是说多个iommu_group或者说vfio_group对应一个vfio_domain</strong>。接着往下继续，如果不满足上面所说的条件(或者初次创建iommu domain_list为空的时候)则</p>
<div class="highlight"><pre><span></span><code><span class="w"> </span><span class="o">/*</span><span class="w"> </span><span class="n">replay</span><span class="w"> </span><span class="n">mappings</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">domains</span><span class="w"> </span><span class="o">*/</span>
<span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">vfio_iommu_replay</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span><span class="w"> </span><span class="n">domain</span><span class="p">);</span>
<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="w">     </span><span class="n">goto</span><span class="w"> </span><span class="n">out_detach</span><span class="p">;</span>
<span class="c1">// 将新创建的domain加到vfio_iommu的domain_list链表里面</span>
<span class="w"> </span><span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_list</span><span class="p">);</span>
</code></pre></div>

<p><code>vfio_iommu_replay</code> 这个函数的主要逻辑是找到<code>iommu-&gt;domain_list</code> 的第一个domain，然后把<code>iommu-&gt;dma_list</code> 下的所有的dma区域全部mapping到新创建的domain里面(当然在初始化阶段这两者都是为空的)。之所以是第一个是因为新创建的domain都是插在domain_list的首部，而头部的domain mapping里面包含了其后面的所有domain的dma mapping。核心逻辑走完，回到<code>vfio_ioctl_set_iommu</code> 函数，这里会把找到的driver和新创建的<code>vfio_iommu</code>赋值给container</p>
<div class="highlight"><pre><span></span><code><span class="nx">container</span><span class="o">-&gt;</span><span class="nx">iommu_driver</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">driver</span><span class="p">;</span><span class="w"> </span><span class="c1">//vfio iommu type1</span>
<span class="nx">container</span><span class="o">-&gt;</span><span class="nx">iommu_data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">data</span><span class="p">;</span><span class="w"> </span><span class="c1">// vfio_iommu</span>
</code></pre></div>

<p>至此，vfio_realize当中跟vm dma相关数据结构初始化有关的工作已经完成，那我们看一下dma 页表的初始化。qemu当中是通过注册memory region listener callback来将vm所有的内存都mapping起来的，具体调用逻辑</p>
<div class="highlight"><pre><span></span><code><span class="nx">vfio_dma_map</span><span class="p">(</span><span class="nx">container</span><span class="p">,</span><span class="w"> </span><span class="nx">iova</span><span class="p">,</span><span class="w"> </span><span class="nx">int128_get64</span><span class="p">(</span><span class="nx">llsize</span><span class="p">),</span>
<span class="w">                       </span><span class="nx">vaddr</span><span class="p">,</span><span class="w"> </span><span class="nx">section</span><span class="o">-&gt;</span><span class="nx">readonly</span><span class="p">);</span>
</code></pre></div>

<p>这里面iova就是gpa， vaddr就是hva，它是通过<code>VFIO_IOMMU_MAP_DMA</code> 这个系统调用来实现的，然后继续追一下这个系统调用的实现</p>
<blockquote>
<ul>
<li><code>vfio_dma_do_map</code><ul>
<li><code>vfio_find_dma</code> // check一下 vfio_iommu的dma_list(红黑树)里面是否已经有了这个dma map的iova区域</li>
<li><code>vfio_link_dma</code> //将要做dma map的iova区域插入到 dma_list。</li>
<li><code>vfio_pin_pages</code> //为hva分配相对应的物理地址，然后pin该物理页</li>
<li><code>vfio_iommu_map</code> //为iommu-&gt;domain_list每个domain做mapping<ul>
<li><code>iommu_map</code>
           -&gt; <code>intel_iommu_map</code>
                    -&gt;<code>domain_pfn_mapping</code> //完成iova到pfn的映射即gpa-&gt;hpa</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>因为iova是gpa，所以当guest里面使用dma_map api直接返回gpa地址，但是由于页表里面映射的也是iova-&gt;hpa，所以这个时候硬件发出的dma操作就能正确进行了。</p>
<h3>总结</h3>
<p>上一篇我们留了几个问题，那么结合上面的分析我们基本上可以回答了
Q: 在非虚拟化场景下iommu=pt和iommu disabled这两者有什么区别？</p>
<p>A: 区别在于是否需要走页表转换，那么在pt场景下应用调用dma map 相关api其返回的都是真实的物理地址，如果hw支持passthrough translation则不需要走，如果不支持则需要走只不需要iova就等hpa。而disable的情况下其返回的是iova且必须要走页表转换</p>
<p>Q：虚拟机里面是没有iommu的，那dma是如何进行的？</p>
<p>A： 虚拟机里面没有iommu那么其所有使用dma map的地方返回的都是gpa，在直通的场景需要需要借助于iommu dma remapping机制才能正常工作。</p>
<p>Q：不同intel iommu硬件下的两个pci设备是如何实现直通给同一个vm的？</p>
<p>A： 不同intel_iommu的两上pci设备直通给同一个vm的时候，这两个设备使用的iova页表的基地是一样的，即同一个dmar_domain的pgd。</p>


             
 
            
            
            






            <hr/>
        </div>
        <section id="article-sidebar" class="span2">
            <h4>Published</h4>
            <time itemprop="dateCreated" datetime="2022-02-06T00:00:00+08:00"> 2 6, 2022</time>
            <h4>Category</h4>
            <a class="category-link" href="./categories.html#articles-ref">articles</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="./tags.html#iommu-ref">iommu
                    <span>5</span>
</a></li>
            </ul>
            





            





        </section>
</div>
</article>
                    </div>
                    <div class="span1"></div>
                </div>
            </div>
        </div>
<footer>




    <div id="fpowered">
        Powered by: <a href="http://getpelican.com/" title="Pelican Home Page" target="_blank" rel="nofollow noopener noreferrer">Pelican</a>
        Theme: <a href="https://elegant.oncrashreboot.com/" title="Theme Elegant Home Page" target="_blank" rel="nofollow noopener noreferrer">Elegant</a>
    </div>
</footer>            <script src="//code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    <script>
    (function () {
        if (window.location.hash.match(/^#comment-\d+$/)) {
            $('#comment_thread').collapse('show');
        }
    })();
    window.onhashchange=function(){
        if (window.location.hash.match(/^#comment-\d+$/))
            window.location.reload(true);
    }
    $('#comment_thread').on('shown', function () {
        var link = document.getElementById('comment-accordion-toggle');
        var old_innerHTML = link.innerHTML;
        $(link).fadeOut(200, function() {
            $(this).text('Click here to hide comments').fadeIn(200);
        });
        $('#comment_thread').on('hidden', function () {
            $(link).fadeOut(200, function() {
                $(this).text(old_innerHTML).fadeIn(200);
            });
        })
    })
</script>

    </body>
    <!-- Theme: Elegant built for Pelican
        License : MIT -->
</html>